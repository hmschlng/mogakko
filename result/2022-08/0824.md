# 24th, Aug 2022 
<br>

# ğŸ result
---

### ğŸ“œ **ìš”ì•½**

<table>
  <tr>
    <td>Task</td>
    <td>Done</td>
  </tr>
	<tr>
		<td><a href = "https://www.acmicpc.net/problem/14499">BOJ 14499. ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°</td>
		<td>âœ”</td>
	</tr>
	<tr>
		<td><a href = "https://www.acmicpc.net/problem/16236">BOJ 16236. ì•„ê¸°ìƒì–´</td>
		<td>âœ”</td>
	</tr>
</table>
<br>

### ğŸ“¸ **ì¸ì¦**
![ìº¡ì²˜](https://i.imgur.com/Y3W83SF.png)
![ìº¡ì²˜](https://i.imgur.com/74DBdjF.png)
<br>

---

### ğŸ“œ **í™œë™ ë‚´ìš©**
<br>

- **BOJ 14499. ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°**
<br>

```java
import java.io.*;
import java.util.*;

class Dice {
//           [  up  ]
//   [ left ][below][ right ]
//           [ down ]
//           [above ]

	int below, above, left, right, up, down;
	int[] pos;
	
	public Dice(int below, int above, int left, int right, int up, int down, int[] pos) {
		this.below = below;
		this.above = above;
		this.left = left;
		this.right = right;
		this.up = up;
		this.down = down;
		this.pos = pos;
	}

	// ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¸ì„ ë•Œ ìœ„ìƒì˜ ë³€ê²½
	public void roll(int dir) {
		int temp = 0;
		
		switch(dir) {
		case 1:		//ë™
			temp=below; below=left; left=above; above=right; right=temp; break;
		case 2:		//ì„œ
			temp=below; below=right; right=above; above=left; left=temp; break;
		case 3:		//ë¶
			temp=below; below=up; up=above; above=down; down=temp; break;
		case 4:		//ë‚¨
			temp=below; below=down; down=above; above=up; up=temp; break;
		}
	}
	
}

public class Main {
	static int N,M,R,C,K;
	static int[] cmd;
	
	static int[][] map;	// 0 -> ì£¼ì‚¬ìœ„ ë°”ë‹¥ìˆ«ìê°€ ì§€ë„ì— , !0 -> ì§€ë„ ìˆ«ìê°€ ì£¼ì‚¬ìœ„ ë°”ë‹¥ì— 
	static Dice dice;
	
	static int[] dr = {0,0,0,-1,1}; //ìš°ì¢Œìƒí•˜
	static int[] dc = {0,1,-1,0,0};
	
	static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		R = Integer.parseInt(st.nextToken());
		C = Integer.parseInt(st.nextToken());
		K = Integer.parseInt(st.nextToken());
		
		map = new int[N][M];
		for (int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine());
			for (int j = 0; j < M; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}
		
		st = new StringTokenizer(br.readLine());
		cmd = new int[K];
		for (int i = 0; i < K; i++) {
			cmd[i] = Integer.parseInt(st.nextToken());
		}
		
		dice = new Dice(0,0,0,0,0,0,new int[] {R,C});
		for (int i = 0; i < K; i++) {
			dice.pos = simulate(cmd[i]);
		}
		System.out.println(sb);
	}

	private static int[] simulate(int cmd) {
		int nr = dice.pos[0] + dr[cmd];
		int nc = dice.pos[1] + dc[cmd];
		
		if(!isIn(nr,nc)) return dice.pos;
		
		dice.roll(cmd);
		
		if(map[nr][nc] == 0) {
			map[nr][nc] = dice.below;
		}
		else {
			dice.below = map[nr][nc];
			map[nr][nc] = 0;
		}
		
		sb.append(dice.above).append("\n");
		
		return new int[] {nr,nc};
	}

	private static boolean isIn(int r, int c) {
		return 0<=r&&r<N && 0<=c&&c<M;
	}
	
	
}
```

<br>

- **BOJ 16236. ì•„ê¸°ìƒì–´**

```java
import java.io.*;
import java.util.*;
class Shark {
	int[] pos;
	int time,size,exp;
	boolean needHelp;
	
	public Shark(int[] pos, int time, int size, int exp, boolean needMom) {
		this.pos = pos;
		this.time = time;
		this.size = size;
		this.exp = exp;
		this.needHelp = needMom;
	}
	public boolean canEat(int fish) {
		return fish != 0 && size > fish;
	}
	public boolean canPass(int fish) {
		return this.size >= fish;
	}
}

public class Main {
	static int N;
	static int[][] sea;	/* 0(ë¹ˆì¹¸) , 1 ~ 6(ë¬¼ê³ ê¸° í¬ê¸°) , 9(ìƒì–´ ìœ„ì¹˜) */
	static Shark shark;
	static boolean[][] v;
	static int[] dr = {-1,0,0,1}; // ìƒì¢Œìš°í•˜
	static int[] dc = {0,-1,1,0};
	static List<int[]> fishes;
	static int minR,minC;
	static boolean isBlocked = false;
	
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		N = Integer.parseInt(br.readLine());
		fishes = new ArrayList<>();
		shark = new Shark(new int[] {-1,-1},0,2,0,false);
		sea = new int[N][N];
		for (int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine());
			for (int j = 0; j < N; j++) {
				sea[i][j] = Integer.parseInt(st.nextToken());
				if(sea[i][j] == 9) {
					shark.pos = new int[] {i,j};
				}
				else if(1 <= sea[i][j] && sea[i][j] <= 6) {
					fishes.add(new int[] {i,j});
				}
			}
		}
		Collections.sort(fishes, (x,y) -> sea[x[0]][x[1]] - sea[y[0]][y[1]]);
		while(!shark.needHelp) {
			if(needMom()) {
				shark.needHelp = true;
			}
			v = new boolean[N][N];
			bfs();
		} 
		System.out.println(shark.time);
	}
	
	private static void bfs() {
		Queue<int[]> q = new ArrayDeque<int[]>();
		q.add(new int[] {shark.pos[0],shark.pos[1],0});
		v[shark.pos[0]][shark.pos[1]] = true;
		sea[shark.pos[0]][shark.pos[1]] = 0;
		
		int minTime = Integer.MAX_VALUE;
		minR = shark.pos[0]; 
		minC = shark.pos[1];
		int blockCnt = 0;
		
		while(!q.isEmpty()) {
			int[] cur = q.poll();
			/* 
			 * ìµœì  ë¬¼ê³ ê¸° ì°¾ê¸° :
			 * 1. ê±°ë¦¬ê°€ ê°™ì€ í•œë„ ë‚´ì—ì„œ 
			 * 2. ë¨¹ì„ ìˆ˜ ìˆìœ¼ë©´ 
			 * 	ã„´í–‰ì´ ë” ì‘ìœ¼ë©´ 
			 * 		ã„´í–‰ì´ ê°™ì„ ë•Œ ì—´ì´ ë” ì‘ìœ¼ë©´ ì¢Œí‘œ ì„ íƒ 
			*/ 
			if(minTime < cur[2]) break;
			if(shark.canEat(sea[cur[0]][cur[1]])) { 
				if(minTime == Integer.MAX_VALUE ||
					(minTime == cur[2] && minR > cur[0]) ||
					(minTime == cur[2] && minR == cur[0] && minC > cur[1])) {
							minR = cur[0];
							minC = cur[1];
							minTime = cur[2];
				}
			}				
			// ì‚¬ë°©íƒìƒ‰
			blockCnt = 0;
			for (int d = 0; d < 4; d++) {
				int nr = cur[0] + dr[d];
				int nc = cur[1] + dc[d];
				if(!isIn(nr,nc) || v[nr][nc] || !shark.canPass(sea[nr][nc])) {
					blockCnt++;
					continue;
				}
				q.offer(new int[] {nr,nc,cur[2]+1});
				v[nr][nc] = true;
			}
		}
		// ë¬¼ê³ ê¸°ë¥¼ ë¨¹ì§€ ëª»í–ˆì„ ë•Œ
		if(minR == shark.pos[0] && minC == shark.pos[1]) {
			if(blockCnt == 4) {
				shark.needHelp = true;
			}
		}
		// ë¬¼ê³ ê¸° ì†Œë©¸, ìƒì–´ìœ„ì¹˜ ë³€ê²½
		fishes.removeIf(x -> x[0] == minR && x[1] == minC);
		sea[minR][minC] = 9;
		// ìƒì–´ì˜ ì •ë³´ ì—…ë°ì´íŠ¸ (ì‹œê°„, ìœ„ì¹˜, í¬ê¸°, ê²½í—˜ì¹˜)
		shark.time += (minTime == Integer.MAX_VALUE) ? 0 : minTime;
		shark.pos = new int[] {minR,minC};
		if(shark.exp == shark.size-1) {
			shark.size++;
			shark.exp = 0;
		} 
		else shark.exp++;
	}
	public static boolean needMom() { // ì—„ë§ˆê°€ í•„ìš”í•œì§€ í™•ì¸
		if(fishes.isEmpty()) return true;
		for (int[] fish : fishes) { 
			if(shark.canEat(sea[fish[0]][fish[1]])) return false;
		}
		return true;
	}
	private static boolean isIn(int r, int c) {
		return 0<=r&&r<N && 0<=c&&c<N;
	}
}
```